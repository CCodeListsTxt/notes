[toc]

## 进制转换

### R进制转十进制

『按权展开』。如$$(0.01)_2$$转换为十进制：
$$
(0.01)_2 = (0 \times 2^{-1} +1 \times 2^{-2})_{10} = (0.25)_{10}
$$

### 十进制转R进制

#### 小数部分

『乘基取整』。将小数部分乘以基数，得到的整数部分作为转换后的位，小数部分重复操作，直到小数部分为0[^2]。

如$$(0.6875)_{10}$$转换为二进制：
$$
0.6875 \times 2 = 1.375 \\
0.375 \times 2 = 0.75 \\
0.75 \times 2 = 1.5 \\
0.5 \times 2 = 1.0 \\
所以：(0.6875)_{10} = (0.1011)_2
$$

### 二、八、十六转换

二、八、十六进制转换时，只需将各个位转换为对应进制数即可。

## 数值表示

### 整数

#### 原码表示

使用最高位表示『符号』，其余位表示『数值』，n位字可表示『-2^n-1^~2^n-1^』范围的数值。

存在两个0，且加法和减法必须使用『加法计算器』和『减法计算器』实现。

#### 补码表示

数与其『补数』的和总是一个常数，在n位二进制算数中，数$$N$$的『补码』为$$2^n - N$$。即二进制算数中，求数$$N$$的『补码』，只需将$$N$$按位取反，然后加一[^1]。

二进制算数中，对于任意有符号数$$N$$，存在$$-N = N的按位取反 + 1$$。[示例](#示例1)

#### 移码表示

数的『原码表示』加上一个『偏置常数』。

偏置常数为『2^n-1^』时，表示相同数值的『移码』和『补码』只有第一位不同。

### 浮点数

任意实数x可表示为$$x = (-1)^s \times M \times R^E$$，其中：

* $$M$$是二进制定点小数，称为『尾数』，决定表示精度。
* $$E$$是二进制定点整数，称为『阶』，决定表示范围。
* $$R$$为『基数』，可约定为2、4、16等。

#### IEEE754

IEEE754标准中，尾数使用『原码』表示，阶码使用『移码』表示，偏置常数为『$$2^{n-1} - 1$$』[^3]。IEEE754单精度浮点数的表示方式如下[^4]：[示例](#示例2)

<img src="./../../../../AppData/Roaming/Typora/typora-user-images/image-20230912095144275.png" alt="image-20230912095144275" style="zoom:50%;" />

| 值类型      | 符号 | 阶码        | 尾数        | 值                  |
| ----------- | ---- | ----------- | ----------- | ------------------- |
| 正/负零     | 0/1  | 0           | 0           | 0                   |
| 正/负无穷大 | 0/1  | 255         | 0           | ±无穷               |
| 非数        | 0/1  | 255         | 非0         | NaN                 |
| 规格化数    | 0/1  | $$0<e<255$$ | $$f$$       | ±$$2^{e-127}(1.f)$$ |
| 非规格化数  | 0/1  | 0           | $$f \ne 0$$ | ±$$2^{-126}(0.f)$$  |





# 示例

## 示例1

```cpp
auto main() -> int {
	char c = 10;
	std::println("{}", std::bitset<8>(c).to_string());  // 00001010
	std::println("{}", std::bitset<8>(-c).to_string()); // 11110110
	std::println("{}", ~c + 1);		// -10
	std::println("{}", ~(-c) + 1);	// 10

	return 0;
}
```

## 示例2

```cpp
float a = 0;
auto main() -> int {
	// Inf
	*reinterpret_cast<unsigned*>(&a) = 0b0'11111111'00000000000000000000000;
	std::println("{}", a);

	// NaN
	*reinterpret_cast<unsigned*>(&a) = 0b0'11111111'00000000000000000000001; 
	std::println("{}", a);

	// 1.5
	*reinterpret_cast<unsigned*>(&a) = 0b0'01111111'10000000000000000000000;
	std::println("{}", a);

	return 0;
}
```







[^1]:$$N + N的按位取反 = n位二进制最大表示 = 2^{n} - 1$$
[^2]:转换时，小数部分可能总不为零，只能得到『近似值』
[^3]:单精度偏置常数为127；双精度偏置常数为1023
[^4]:其中『1.f』为二进制表示