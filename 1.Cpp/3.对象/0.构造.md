

#### 初始化

###### 默认初始化

默认初始化在以下情况进行：

> 1. 不带初始化器创建的对象，如：`T t`，`new T`。

默认初始化的效果：

> 1. 如果T是类类型，对空实参列表的构造函数进行重载决议，并调用进行初始化。
> 2. 如果T是数组类型，则默认初始化所有元素。
> 3. 否则，不做任何事情（具有自动存储期的对象初始化为不确定值）。



###### 零初始化

###### 值初始化

值初始化在以下情况进行：

> 1. 以空的括号或花括号对组成的初始化器创建临时对象，如：`T()`、`T{}`、`new T()`、`new T{}`。
> 2. 以空的花括号对组成的初始化器创建具名对象，如`T t{}`。

任何情况下，使用空花括号对初始化时：

> 1. 如果T是聚合类型，那么进行聚合初始化而非值初始化。
> 2. 如果T没有默认构造函数，但有接受`std::initializer_list`的构造函数，那么进行列表初始化。

值初始化的效果：

> 1. 如果T没有默认构造函数（或被删除），那么对象被默认初始化。
> 2. 如果T具有合成构造函数，那么零初始化对象。
> 3. 如果T具有非平凡的默认构造函数，那么默认初始化。
> 4. 如果T是数组类型，那么值初始化数组所有元素。
> 5. 否则，零初始化对象。





###### 转换构造函数

不使用`explicit`声明的构造函数即为转换构造函数，转换构造函数可以用于直接初始化和复制初始化。









###### 构造

`cv`限定符声明的对象在构造函数调用之后才会拥有`cv`属性。









构造对象的过程：
1. 为该对象分配一块空间。
2. 如果空间地址不为`nullptr`，调用构造函数初始化这块空间。

以函数形式构造对象时，参数表达式计算顺序不定；以列表初始化方式构造时，参数表达式从左往右计算。

```cpp
struct A
{
    A(int i) { std::cout << i; }
};

int main()
{
    std::tuple t1(A{0}, A{1});  // gcc : 10；clang : 01
    std::cout << "\n";
    std::tuple t2{A{0}, A{1}};  // 01

    return 0;
}
```

###### 默认构造函数

不需要参数、或所有参数都具有默认值的构造函数，就是默认构造函数。

类可以定义多个默认构造函数。但如果使用默认构造的方式创建对象，将报错。

###### 合成构造函数

当编译器需要默认构造函数，但未定义时，编译器会自动合成一个默认构造函数。以下情况会合成默认构造：
1. 对象成员具有默认构造函数（包含合成的默认构造）。
2. 基类具有默认构造函数。
3. 具有虚函数（编译器需要插入代码，以初始化虚指针）。
4. 继承链中有虚继承（编译器需要插入代码，以初始化虚基类指针）。
5. 使用`=default`显示让编译器合成。

合成的构造函数不会初始化内置类型和复合类型成员。

###### 初始化列表

只有在初始化列表中进行的才是初始化操作，构造函数体中的操作属于赋值。所以常量成员只能在初始化列表中进行初始化。

初始化列表只负责初始化的值，初始化顺序与在类中定义的顺序一致。

###### 委托构造

在初始化列表中可以调用自身或基类的构造函数，且使用委托调用后，初始化列表中只能存在该调用作为唯一的成员初始化器。

循环调用委托构造属于未定义行为，且编译器不一定会做检测。

###### 转换构造函数

可以只接受一个参数的构造函数，定义了将其他类型数据转换为该类的机制。默认支持隐式转换，使用`explicit`关键字，只支持显示调用。

对于隐式转换，编译器只会进行一步转换。

```cpp
struct A
{
    A(int) {}
};

struct B
{
    B(A) {}
};

int main()
{
    B b1 = 1;		// 隐式转换失败
    B b2(1);		// 显示转换成功
    return 0;
}
```

###### 继承构造函数

在派生类中使用`using`声明基类的构造函数，当派生类中不存在基类构造函数参数匹配的构造函数时，编译器将会合成与基类构造函数参数匹配的构造函数。

该声明不会改变构造函数的访问权限。

```cpp
struct Base
{
    Base(int)
    {
        std::cout << "Base(int)" << std::endl;
    }
};

struct Derive
{
    using Base::Base;
};

int main()
{
    Derive(0); // Base(int)
    return 0;
}
```
