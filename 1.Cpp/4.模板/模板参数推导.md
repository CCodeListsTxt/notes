[toc]
---

#### P/A对

P指代参数类型（包括类型模板参数、模板模板参数以及非类型模板参数）。

A指代具体实参（可以是类型、模板或值）。

当有多个模板参数时，则分别推断每个P/A对，然后组合推导的模板参数。如果推导失败或任意P/A对不明确，将编译失败。

>   **示例：**
>
>   ```cpp
>   template <template <typename...> typename Container, typename T, typename... Args>
>    auto memset_container(Container<T> &con, Args &&...args) -> void {
>       con = {args...};
>    }
>   
>   auto main() -> int {
>       auto vec = std::vector{1, 2, 3};
>       memset_container(vec, 4, 5, 6);
>        // P = Container<T>& ; A = vec  ;  deduced Container<T> = std::vector<int>
>        // P = Args&&...     ; A = 4    ;  deduced first of Args... = int
>        // ...
>    
>        for (const auto &n : vec) {
>           std::println("{}", n);
>        }
>    
>        return 0;
>   }
>    ```

---

#### 推导调整

在推导开始之前，会对P和A进行以下调整：

>   *    如果P不是引用类型：
>
>       >   *   如果A是数组、函数类型，转化为指针类型。
>       >
>       >       >   **示例：**
>       >       >
>       >       >   ```cpp
>       >       >   auto call_no_ref(auto p) -> void {
>       >       >       std::println("{}", typeid(decltype(p)).name());
>       >       >    }
>       >       >   
>       >       >   auto call_on_ref(auto &p) -> void {
>       >       >       std::println("{}", typeid(decltype(p)).name());
>       >       >   }
>       >       >    
>       >       >   auto main() -> int {
>       >       >       int arr[] = {1, 2, 3};
>       >       >   
>       >       >       call_no_ref(arr); // Pi
>       >       >        call_on_ref(arr); // A3_i
>       >       >   
>       >       >        call_no_ref(main); // PFivE
>       >       >        call_on_ref(main); // FivE
>       >       >   
>       >       >        return 0;
>       >       >    }
>       >       >   ```
>       >       
>       >   *   如果A具有cv限定符，推导时忽略顶层cv限定符。
>       >   
>       >    >   **示例：**
>       >       >
>       >    >   ```cpp
>       >       >   auto call_no_ref(auto p) -> void {
>       >       >       std::println("{}", std::is_const_v<decltype(p)>);
>       >       >    }
>       >       >   
>       >       >   auto main() -> int {
>       >       >       const int a = 10;
>       >       >       call_no_ref(a); // false
>       >       >    
>       >       >        return 0;
>       >       >   }
>       >       >    ```
>       
>   *   如果P具有cv限定符，推导时忽略顶层cv限定符。
>   
>       >   **示例：**
>       >
>    >   ```cpp
>       >   template <typename T>
>    >   auto call(const T &p) -> void {
>       >       std::println("{}", std::is_const_v<T>);
>       >    }
>       >   
>       >   auto main() -> int {
>       >       const int a = 10;
>       >       call(a); // false
>       >    
>       >        return 0;
>       >   }
>       >    ```
