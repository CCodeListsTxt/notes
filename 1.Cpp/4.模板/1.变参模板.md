使用`typename...`声明一组类型和参数都不确定的模板参数，使用`Types...`声明参数包，使用`sizeof...()`运算符，获取参数包中包含的参数数量。

```cpp
template <typename T>
auto print(T val) -> void { std::cout << val << std::endl; }

template <typename T, typename... Types>
auto print(T val, Types... args) -> void
{
    std::cout << val << "; ";
    print(args...);
}

auto main() -> int
{
    print(1, 2, 3, "hello"); // 1; 2; 3; hello
    return 0;
}
```

###### 折叠表达式

C++17提供了四种折叠表达式，可用于计算参数包中所有参数的二元求值结果。

* `(... opt pack)`，从左往右运算。
* `(opt pack ...)`，从右往左运算。
* `(init opt ... opt pack)`，参数包前加上初始值，从左往右运算。
* `(pack opt ... opt init)`，参数包后加上初始值，从右往左运算。

>   通常会使用`,`运算符对模版参数包进行解包操作。

```cpp
template <typename... Types>
auto left_div_right(Types... args) { return (... / args); }

template <typename... Types>
auto right_div_left(Types... args) { return (args / ...); }

auto main() -> int
{
    std::cout << left_div_right(1000, 100, 10, 1) << std::endl; // 1000 / 100 / 10 / 1 == 1
    std::cout << right_div_left(1000, 100, 10, 1) << std::endl; // 1000 / (100 / (10 / 1)) == 100
    return 0;
}
```

标准库提供了`std::integer_sequence<INT_TYPE, INDEX>`表示编译时的整数序列，常用于表示模板参数包。

```cpp
template <size_t... I>
auto call(std::index_sequence<I...>) -> void {

    ((std::cout << I), ...); // 0 1 2 3 4
}

auto main() -> int {

    call(std::make_index_sequence<5>());

    return 0;
}
```

