#### typename

使用模板内部的标识符时，其默认被假设为非类型成员。因此，当一个依赖模板的名称表示某种类型时，需要在其前面加上 `typename` 关键字。


#### 使用 this->

对于类模板，如果其基类也是依赖于模板参数的，那么即使 x 是继承的，`this->x` 和 `x` 也不一定等效。

如果没有通过显示的方式说明 x 是基类的成员，那么永远不会在基类中寻找 x。
```cpp
template<typename T>
struct Base {
    auto func() { std::cout << "base func\n"; }
};

template<typename T>
struct Derive : public Base<T> {
    auto call() { func(); } // func 找不到标识符
};
```

可以使用显示的 `using` 声明基类的x，或者使用 `this->x`，或者使用 `Base::x`。

#### 使用裸指针或字符串常量的模板

定义专门处理裸指针和字符串常量的模板，类型推导会推断出N的大小。

```cpp
template<typename T, int N>
auto func(T(&arr)[N]) {}
```