[toc]

在语境中使用T1类型的表达式，但该语境需要接受另一T2类型时，会进行隐式类型转换。

#### 转换顺序

隐式转换的顺序如下：

1. 零或一个[标准转换](#标准转换)。
2. 零或一个[用户定义转换]()。
3. 零或一个[标准转换]()（在构造函数实参、用户定义转换函数实参、非类型转换到另一个非类型时，不会进行此过程）[示例](#示例1)。

###### 标准转换

标准转换的顺序如下：

1. 零或一个[值变换](#值变换)。
2. 零或一个[数值提升](#数值提升)、[数值转换](#数值转换)。
3. 零或一个[函数指针转换](#函数指针转换)。
4. 零或一个[限定转换]()。

###### 用户定义转换

用户定义转换由零或一个非显示单实参[转换构造函数]()或非显示[转换函数]()的调用构成。

#### 值变换

值变换是更改表达式[值类别]()的转换。

###### 左值转右值

非函数、非数组类型T的[泛左值]()可以隐式转换为[纯右值]()。

###### 数组到指针

“T的N元素数组”或“T的未知边界数组”类型的左值或右值，可隐式转换为“指向T的指针”类型的[纯右值]()，产生的指针指向数组首元素。

###### 函数到指针

函数类型T的左值，可隐式转换为“指向该函数的指针”的[纯右值]()（并不适用于非静态成员函数，非静态成员函数不存在左值）。

###### 临时量实质化

任何完整类型T的[纯右值]()，可隐式转换为该类型的[亡值]()，以下情况会发生临时量实质化：

* 绑定引用到纯右值（[延长生命周期]()）。
* 在类纯右值上进行[成员访问]()。
* 进行[数组到指针的转换]()或定义[数组纯右值]()。
* 纯右值作为[弃值表达式]()。[示例](#示例2)

使用[纯右值]()初始化对象时，不会进行临时量实质化，而是直接从初始化器初始化对象。

#### 数值提升

数值提升不会造成精度损失。

###### 整数提升

小整数类型的纯右值可以转换为较大整数类型，内置[算数运算符]()不接受小于[int]()的类型作为其操作数，小于[int]()类型的操作数会先尝试转换为[纯右值]()，然后进行[整数提升]()到[int]()。

小于[int]()类型的整数都会提升到[int]()类型，如函数决策中，`char -> int（提升）`优先于`char -> short（转换）`。[示例](#示例3)

###### 浮点提升

[float]()类型[纯右值]()可以提升为[double]()类型[纯右值]()。

#### 数值转换

数值转换存在潜在的精度损失。

###### 整数转换

任何整数类型或无作用域的枚举类型的『纯右值』可隐式转换为任意其他整数类型（如果该转换符合[数值提升]()，进行提升而非转换）。进行整数转换时，遵守如下规则：

* 如果『目标类型』无符号，那么结果值为 $$原始值 \bmod 2^n$$ 的最小无符号值，其中n表示『目标类型』的位数。即：
  * 如果『目标类型』更宽，对有符号原始值进行符号拓展 （如果原始值为负数，结果值等价为$$2^n + 原始值$$），对无符号原始值进行零拓展。[示例](#示例4)
  * 如果『目标类型』更窄，对原始值进行截断。
* 如果『目标类型』有符号，如果原始值能以目标类型表示，则不会改变其值；否则，结果值为 $$原始值 \bmod 2^n$$（与[有符号整数算数溢出]()的未定义行为不同）。[示例](#示例5)

#### 函数指针转换

指向『无抛出函数』的指针类型的纯右值，可以转换为指向『潜在抛出函数』的指针纯右值。[示例](#示例6)

#### 限定性转换





# 示例

###### 示例1

```cpp
struct T1 {
    operator int() const { return 0; }
};

struct T2 {
    T2(int i) {}

    operator int() const { return 0; }
};

auto main() -> int {
    double d  = T1{};      // ok    :   T1 -> int -> double
    T2     _  = T1{};      // error :   T1 -> int -\> T2
    T2     __ = T2{T1{}};  // ok    :   T1 -> int

    return 0;
}
```

###### 示例2

```cpp
struct T {
    T() { std::cout << "T\n"; }
};

auto main() -> int {
    T{};    // T

    return 0;
}
```

###### 示例3

```cpp
auto call(int) -> void { std::cout << "int\n"; }
auto call(short) -> void { std::cout << "short\n"; }

auto main() -> int {
    call(char{});  // int
    return 0;
}
```

###### 示例4

```cpp
auto main() -> int {
    char a = -100;
    std::cout << static_cast<unsigned short>(a) << "\n";  // 65436
    std::cout << (-100 % 65536) + 65536 << "\n";          // 65436

    return 0;
}
```

###### 示例5

```cpp
auto main() -> int {
    int a = 65537;
    std::cout << static_cast<short>(a) << "\n";   // 1
    std::cout << (65537 % 65536) << "\n";             // 1
    std::cout << static_cast<short>(-a) << "\n";  // -1
    std::cout << (-65537 % 65536) << "\n";            // -1

    return 0;
}
```

###### 示例6

```cpp
auto call_except() -> void {}

auto call_noexcept() noexcept -> void {}

auto main() -> int {
    using call_except_t   = void (*)();
    using call_noexcept_t = void (*)() noexcept;

    call_except_t{&call_noexcept};
    call_noexcept_t{&call_except};  // error，“抛出函数指针”不能转换为“无抛出函数指针”

    return 0;
}
```

