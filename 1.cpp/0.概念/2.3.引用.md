[toc]

# 引用初始化

引用并不是对象[^1]，因此，初始化引用时，必须将其绑定到对象上，且不能再次绑定。

对`T`的引用能绑定到 `T类型对象`、`T类型函数`或可**隐式转换**为`T`类型的对象。

初始化非常量左值引用时：

* 如果目标是**左值表达式**，且其是`T类型`或`T的派生类`，且存在相等或更少的cv限定，引用绑定到表达式对象或其基类子对象。

* 如果目标的类型与`T`不同且非`T`的派生，但目标拥有到`T类型`或`T派生类型`的**类型转换函数**，引用绑定到转换函数返回的对象。

  ```cpp
  struct T {
  	static inline int i = 0;
  	operator int& () { return i; }
  };
  
  auto main() -> int {
  	int& ref = T{};	// ref 绑定到 T::i
  	ref = 20;
  	std::println("{}", T::i);	// 20
  
  	return 0;
  }
  ```

# 延长生存期

初始化**常量左值引用**或**右值引用**时，如果绑定到临时对象或其子对象，临时对象的生存期就会延长以匹配引用的生存期。

```cpp
struct T {
	~T() {
		std::println("{} destruct", i);
	}
	int i;
};

auto main() -> int {
	T{ 1 };	// 1 destruct
	{
		const auto& ref = T{ 2 };
		std::println("--------");
	}	// 2 destruct
	auto&& ref = T{ 3 };
	std::println("--------");

	return 0;
}	// 3 
```

但上述规则存在以下例外：

* 函数返回临时对象或其子对象的引用，该对象的生存期不会被延续，且始终返回**悬垂引用**。

* 初始化具有引用成员的聚合体时[^2]：
  * 如果使用**直接初始化**，不会延长生存期。
  * 如果使用**列表初始化**，会延长生存期。

总之，临时对象的生存期不能通过引用传递。

# 引用折叠

通过**模板**或**类型别名**构成引用类型时，会执行引用折叠的规则：

* 右值引用的右值引用折叠为右值引用。
* 其它组合折叠为左值引用。

---

[^1]:编译器为了实现引用，通常会占据指针大小的内存
[^2]:**直接初始化**调用构造函数，而**初始化列表**进行原地绑定