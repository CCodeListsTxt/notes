[toc]

## 引用初始化

引用并不是对象，其并不会占用存储空间[^1]。因此，在初始化引用时，必须将其绑定到对象上，且一旦初始化，就不能再次绑定。

对T的引用能绑定到T类型对象、T类型函数或可隐式转换为T类型的对象。

初始化非常量左值引用时：

* 如果目标是[左值表达式]()，且其类型是T或T的派生类，且存在相等或更少的cv限定，那么引用绑定到表达式对象或其基类子对象。
* 如果目标的类型与T不同且不从T派生，但目标拥有到类型T或T派生类型的[类型转换函数]()，那么绑定到转换函数返回的左值对象。[示例](#示例1)

## 延长生存期

初始化[常量左值引用]()或[右值引用]()时，如果绑定到临时对象或其子对象，临时对象的[生存期]()就会延长以匹配引用的[生存期]()。[示例](#示例2)

但上述规则存在以下例外：

* 函数返回临时对象或其子对象的引用，该对象的[生存期]()不会被延续，这种方式始终返回[悬垂引用]()。[示例](#示例3)

* 初始化具有引用成员的聚合体时[^2]：[示例](#示例4)
  * 如果使用[直接初始化]()，不会延长[生存期]()。
  * 如果使用[列表初始化]()，会延长[生存期]()。

总之，临时对象的[生存期]()不能通过引用传递。

## 引用折叠

通过[模板]()或[类型别名]()构成引用的引用时，会执行引用折叠的规则：

* 右值引用的右值引用折叠为右值引用。
* 其它组合折叠为左值引用。

# 示例

## 示例1

```cpp
struct T {
    static inline int i = 0;

    operator int &() { return i; }
};

auto main() -> int {
    int &r = T{};
    r = 10;
    std::cout << T::i << "\n";  // 10

    return 0;
}

```

## 示例2

```cpp
struct T {
    ~T() { std::cout << i << " destruct\n"; }

    int i;
};

auto main() -> int {
    {
        T{1}; // 1 析构
        std::cout << "--------\n";
        const int &ref = T{2}.i; // 延长生存期
        std::cout << "--------\n";
    } // 2 析构
    std::cout << "--------\n";
    return 0;
}
```

## 实例3

```cpp
struct T {
    ~T() { std::cout << "~T()\n"; }

    int i;
};

auto main() -> int {
    const int& ref = []-> int& {
       T t;
       return t.i;
    }(); // 析构
    std::cout << "---------\n";

    return 0;
}
```

## 示例4

```cpp
struct T {
    ~T() { std::cout << i << " destruct\n"; }

    int i;
};

struct S {
    int &&i;
};

auto main() -> int {
    {
        S s1{T{1}.i}; // 延长生存期
        std::cout << "-----\n";
        S s2(T{2}.i);   // 2 析构
        std::cout << "-----\n";
    } // 1 析构
    std::cout << "-----\n";

    return 0;
}
```





[^1]:编译器为了实现某些语义可能会分配内存空间
[^2]:通过[直接初始化]()走的是构造函数，而[初始化列表]()进行原地绑定