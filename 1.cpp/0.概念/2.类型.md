c++的类型系统主要分为两大类：_基础类型_ 和 _复合类型_。

## 基础类型
基础类型包括空类型、空指针类型、算数类型。

#### 算数类型
###### 标准整数类型
`int` 是基本整数类型，可以通过以下修饰符得到特定的整数：
* 符号修饰符：
  *   `signed`，目标类型为有符号表示（默认）。
  *   `unsigned`，目标类型为无符号表示。
* 尺寸修饰符：
  *   `short`，目标类型至少为16位宽度。
  *   `long`，目标类型至少为32位宽度。
  *   `long long`，目标类型至少为64为宽度。

使用修饰符时，可以忽略 `int`，且可随意交换修饰符的位置，如 `unsigned long long` 和 `long unsigned int long`表示相同类型。

###### 定宽整数类型
头文件 `<cstdint>` 中定义了定宽整数类型。如 `int32_t`、`uint32_t`。

###### 标准浮点类型
有三种标准浮点类型，且均遵守 IEEE754 标准：
* `float`，单精度浮点类型，使用 `f` 后缀表示字面量。
* `double`，双精度浮点类型，默认字面量表示。
* `long double`，拓展精度浮点模式（由实现决定64位或128位），使用 `l` 后缀表示字面量。
```cpp
auto main() -> int {
    std::println("{}", 0.1f + 0.2f == 0.3f);  // true
    std::println("{}", 0.1 + 0.2 == 0.3);     // false
    std::println("{}", 0.1l + 0.2l == 0.3l);  // 未定义
    return 0;
}
```

###### 定宽浮点类型
头文件 `<stdfloat>` 中定义了定宽浮点数类型以及对应字面量。如 `float32_t`。

## 复合类型
复合类型包括引用类型、指针类型、数组类型、函数类型、枚举类型、类类型。

#### 引用类型
###### 初始化
引用并不是对象（虽然为了实现引用，会占据指针大小的空间），因此初始化引用时，必须将其绑定到对象上，且不能再次绑定。

对T的引用，可以绑定到T类型对象、T类型函数，或可隐式转换为T类型的对象。

初始化非常量左值引用时：
* 如果目标是左值表达式，且其是T类型或T的派生类型，且存在相等或更少的cv限定，引用绑定到表达式对象或其基类子对象。
* 如果目标拥有到T类型或T的派生类型的类型转换函数，引用绑定到转换函数返回的对象。
  ```cpp
  struct T {
      static inline int i = 0;
      operator int& () { return i; }
  };

  auto main() -> int {
      int& ref = T{};     // 绑定到 T::i
      ref = 20;
      std::cout << T::i;  // 20
      return 0;
  }
  ```

###### 延迟生命周期
初始化常量左值引用或右值引用时，如果绑定到临时对象或其子对象，将延长临时对象的生命周期，以匹配引用的生命周期。

但上述规则存在一下例外：
* 函数返回其局部对象或子对象的引用时，其生命周期不会延续，且返回悬垂引用。
* 在函数调用时，绑定到函数参数的临时量，其生存周期延续到函数调用的全表达式结尾（`;`）。
  ```cpp
  struct T { ~T() { std::cout << "destruct\n"; } };

  auto call1(const T&) { std::cout << "call1\n"; return 0; }

  auto call2() { std::cout << "call2\n"; return 0; }

  auto main() -> int {
      call1(T{}) || call2();  // call1 + call2 + destruct
      return 0;
  }   
  ```
* 初始化具有引用成员的聚合体时：
  * 如果使用直接初始化（`()`），不会延长生命周期。
  * 如果使用列表初始化（`{}`），会延长生命周期。
  ```cpp
  struct T { ~T() { std::cout << "destruct\n"; } };

  struct U { T&& ref; };

  auto main() -> int {
      {
          U u(T{});   // destruct
          std::cout << "----------\n";
      }
      U u{ T{} };
      std::cout << "----------\n";

      return 0;
  }   // destruct
  ```
总之，临时量的生存周期不能通过进一步传递来延续。

#### 指针类型
任何类型的指针都可隐式转换为空指针，但逆向转化必须显示进行。

###### 数据成员指针
指向类 `Class` 的类型为 `Type` 的数据成员的指针，其类型可表示为 `Type(Class::*)`。

数据成员指针的通常实现为数据成员在类结构中的偏移量。

###### 成员函数指针
指向类 `Class` 的类型为 `Ret(Args...)` 的成员函数的指针，其类型可表示为 `Ret(Class::*)(Args...)`。

成员函数指针可以作为普通函数指针调用，其第一个参数作为 `this` 指针。

#### 数组类型
###### 未知边界数组
声明数组时，只有第一个维度可以是未指定边界的。但可以初始化绑定到未知边界数组的引用或指针，且c++20允许使用已知边界的数组对其进行初始化。
```cpp
auto main() -> int {
    int arr[1];
    int(&ref)[] = arr;  // c++20 ok
    int(*ptr)[] = &arr; // c++20 ok
    return 0;
}
```

###### 数组纯右值
数组无法通过函数按值返回，且不能作为大多数转型表达式的目标类型，但可以通过类型别名的方式、并使用 `{}` 初始化构造数组纯右值，且会发生临时量实质化。
```cpp
auto main() -> int {
    struct T{};
    using TArr = T[2];
//  TArr(); error
    TArr{}; // ok
    return 0;
}
```

###### 字符串字面量
字符串字面量的类型为 `const CharT[N]`。默认字符串字面量是 `char` 类型字符序列，使用 `u8`、`u` 和 `U` 前缀表示 `char8_t`、`char16_t` 和 `char32_t` 类型字符序列。

字符串字面量是否会存储到不重叠的对象属于未定义行为，连续求值相同的字符串字面量是否会产生不同的字符串对象也是未定义行为。
```cpp
auto main() -> int {
    // gcc、msvc输出false，clang输出true
    std::cout << ("lo" == (3 + "hello"));	
    return 0;
}
```

###### 原始字符串字面量
在字符串字面量类型前缀后加上 `R` 前缀，表示当前字面量为原始字符串字面量。在原始字符串中，转义字符被解析为普通字符，且其定义可以跨越任意行。

为了指明原始字符串的边界，需要在字符串两端加上 `边界(` 和 `)边界`，边界可以是任意字符串。原始字符串的完整形式为 `R"边界(内容)边界"`。