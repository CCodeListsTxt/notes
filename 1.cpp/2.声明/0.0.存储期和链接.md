[存储类说明符]()和[作用域]()控制符号的两个性质——[存储期]()和[链接]()：

* 无说明符，自动存储期。
* [static]()，静态或线程存储期，内部链接。
* [extern]()，静态或线程存储期，外部链接。
* [thread_loca]()，线程存储期。
* [mutable]()，不影响存储期和链接。

声明中只能存在一个[存储类说明符]()，但[thread_loca]()可以和[static]()或[extern]()组合。

#### 存储期

『自动存储期』：对象在其所处作用域开始时分配，结束时释放。

『静态存储期』：对象在程序开始时分配，程序结束时释放。整个程序中只能存在一个实例。

『线程存储期』：对象在线程开始时分配，线程结束时释放。每个线程中存在一个示例。

『动态存储期』：对象通过[动态内存分配]()函数进行分配和释放。

#### 链接

链接属性用于判断不同『编译单元』中，相同的名字是否指代同一个实体。

###### 无链接

具有『无链接』的名字只能在其作用域中使用，在『块作用域』声明的以下任何名字均是『无链接』的：

* 未显示声明为[extern]()的变量。[示例](#示例1)
* [局部类]()和其成员函数。
* 声明的其他名字，如[typedef]()别名、枚举。

###### 内部连接

具有『内部连接』的名字可以在当前『翻译单元』中使用，在『命名空间作用域』中定义的下列名字均是『内部链接』的：

* 具有[const]()限定，没有[volatile]()限定的『非模板变量』，且：
  * 不是[内联]()的。
  * 没有声明为[extern]()。
* [匿名联合体]()的数据成员。[示例](#示例2)

###### 外部链接

具有『外部链接』的名字在多个『翻译单元』中指代同一个实体。在『命名空间作用域』中的下列名字均是『外部链接』的：

* 未声明为[static]()的函数。
* 为声明为[static]()的非[const]()变量。
* 声明为[extern]()的变量。
* 枚举。
* 类及其成员函数、静态数据成员、嵌套类、枚举。

首次在『块作用域』中声明的下列名字也具有『外部链接』：

* 声明为[extern]()的变量。
* 函数。

#### 静态局部变量

在『块作用域』中声明为[static]()的变量，在首次经过其声明时才初始化[^1]，其后的所有调用中，声明都被跳过。

如果初始化时『抛出异常』，下次经过该声明时会再次初始化。[示例](#示例3)

如果通过『递归』的方式初始化，行为未定义。

如果多个线程尝试同时初始化同一个『静态局部变量』，初始化严格只发生一次[^2]。

# 示例

###### 示例1

```cpp
int i = 10;

auto call_1() {
    int i;  // 局部变量i
    std::cout << i << "\n";
}

auto call_2() {
    static int i;  // 局部静态变量i
    std::cout << i << "\n";
}

auto call_3() {
    extern int i;  // 链接为全局i
    std::cout << i << "\n";
}

auto main() -> int {
    call_1();
    call_2();
    call_3();

    return 0;
}
```

###### 示例2

```cpp
////////////////////////////////////////////// main.cc
union {
	int i;
}anonymous;

auto call() -> void;

auto main() -> int {
	anonymous.i = 10;
	call(); // anonymouse.i = 0

	return 0;
}

////////////////////////////////////////////// test.cc
union {
	int i;
}anonymous;

auto call() -> void {
	std::println("anonymouse.i = {}", anonymous.i);
}
```

###### 示例3

```cpp
bool flag{false};

struct T {
    T() {
        std::println("construct");
        if (!flag) {
            flag = true;
            throw 0;
        }
    }
};

auto call() -> void try {
    static T t;
} catch (...) { }

auto main() -> int {
    call();  // construct
    call();  // construct
    call();  // 无输出

    return 0;
}
```





[^1]:除非其被[零初始化]()或[常量初始化]()。
[^2]:类似行为可使用[std::call_once]()实现。额外产生的开销约为非原子的布尔比较