[shared_ptr<T\>]()是共享式智能指针，多个智能指针对象可以共享一份资源的所有权，当最后一个指针对象释放所有权时，会销毁资源。

在进行资源间共享时，只能通过复制构造或复制赋值将其值给另一个指针对象，直接通过底层指针创建新的指针对象会导致未定义行为。

如无特殊必要，不要将[shared_ptr]()作为函数参数传递，智能指针的拷贝十分影响运行效率。

## 实现

在典型的[shared_ptr]()实现中，其通常只维护两个指针：

* 指向资源的指针。
* 指向控制块的指针。

其中，控制块通常会包括：

* 指向资源的指针，或资源自身。
* 删除器(类型擦除)。
* 分配器(类型擦除)。
* 管理资源的[shared_ptr]()的数量。
* 涉及资源的[weak_ptr]()的数量。

通过[make_shared()]()函数簇构造智能指针对象时，会调用私有构造函数，此时只会调用一次内存分配函数，直接将资源原位构造在控制块中。

## 构造函数

除了基本的构造函数，[shared_ptr]()还有：

* [shared_ptr(ptr, deleter)]()，提供删除器。
* [shared_ptr(other_ptr, ptr)]()，和_other\_ptr_共享资源，且保有无关且不管理的_ptr_。[示例](#示例1)

## 成员函数

[.get()]()，获取存储的指针，与管理的资源可能并不相同。

[operator*]()、[operator->]()，解引用存储的指针。

[operator[]]()，提供对数组的下标访问。

[.use_count()]()，获取管理资源的[shared_ptr]()的数量。

# 示例

## 示例1

```cpp
auto main() -> int {
    struct T {
        int i;
        ~T() { std::cout << i << " destruct\n"; }
    };
    auto ptr = std::shared_ptr<T>{std::make_shared<T>(1), new T{2}};

    return 0;
} // 1 destruct
```

