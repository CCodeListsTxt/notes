## 绑定和解绑

使用[QObject::connect()]()函数簇绑定信号和槽，且返回[Connection]()对象：

* [connect(sender, signal, receiver, slot, type)]()。槽函数可以是_receiver_的成员函数；也可以是任意可调用对象，此时_receiver_不会有任何作用。[示例](#示例1)
* [connect(sender, signal, slot)]()。直接绑定到可调用对象上。

使用[QObject::disconnect()]()函数簇解绑信号和槽：

* [disconnect(sender, signal, receiver, slot)]()。通常有三种解绑形式
  * [disconnect(sender, nullpr, nullpr, nullptr)]()。解绑所有信号。
  * [disconnect(sender, signal, nullptr, nullptr)]()。解绑特定信号。
  * [disconnect(sender, nullptr, receiver, slot)]()。解绑特定接受者。
* [disconnect(connect)]()。解绑特定连接。

### 连接类型

枚举类[ConnectionType]()描述信号槽之间连接的方式：

* `Qt::AutoConnection`。默认值。如果接收方和发送信号在同一线程，其行为为[Qt::DirectConnection]()；否则，其行为为[Qt::QueuedConnection]()。
* [Qt::DirectConnection]()。发出信号后，直接在当前线程立即调用槽。
* [Qt::QueuedConnection]()。当控制回到接收方线程的事件循环时，调用槽。
* [Qt::BlockingQueuedConnection]()。与[QueuedConnection]()类似，会阻塞在发送信号处，直到槽结束。[示例](#示例2)





# 示例

## 示例1

```cpp
struct Sender : public QObject {
    Q_OBJECT
  signals:
    auto signal() -> void;
};

struct Receiver : public QObject {
    Q_OBJECT
  public:
    auto slot() -> void { std::cout << "slot\n"; }
};

auto slot() -> void { std::cout << "slot\n"; }

auto main(int argc, char *argv[]) -> int {
    auto app  = QCoreApplication{argc, argv};
    auto send = Sender{};
    auto recv = Receiver{};
    QObject::connect(&send, &Sender::signal, &recv, &Receiver::slot);
    QObject::connect(&send, &Sender::signal, &recv, [] { std::cout << "slot\n"; });
    QObject::connect(&send, &Sender::signal, &recv, &slot);
    QObject::connect(&send, &Sender::signal, &recv, std::function{slot});
    emit send.signal();  // slot * 4

    return QCoreApplication::exec();
}
```

## 示例2

```cpp
struct Sender : public QObject {
    Q_OBJECT
  signals:
    auto signal() -> void;
};

struct Receiver : public QObject {
    Q_OBJECT
  public:
    auto slot() -> void { std::cout << "slot\n"; }
};

auto main(int argc, char *argv[]) -> int {
    auto app      = QCoreApplication{argc, argv};
    auto sender   = Sender{};
    auto receiver = Receiver{};

    QObject::connect(&sender, &Sender::signal, &receiver, &Receiver::slot, Qt::BlockingQueuedConnection);
    QThread::create([&] {
        emit sender.signal();  // 阻塞直到slot()结束
        std::cout << "------------\n";
    })->start();
    QThread::sleep(1);

    return QCoreApplication::exec();
}
// 输出：
// slot
// ------------
```

