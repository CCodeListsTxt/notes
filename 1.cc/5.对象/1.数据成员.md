[toc]

声明[非静态数据成员]()时，存在以下限制：

* 不能使用存储类说明符，如[extern]()、[register]()、[thread_local]()。
* 不能使用[不完整类型]()、[抽象类类型]()或其数组[^1]。
* 不能使用[占位符]()[^2]、[待决名]()、[约束占位符]()。
* 存在『用户定义构造函数』时，成员名不能和类名相同。

## 内存分布

c++23前，对于[非联合类类型]()：[非零大小]()的、未被[访问说明符]()分隔的成员，始终按照『后声明的成员在类对象中有较高地址』的方式分配。被[访问说明符]()分隔的成员，未定义。

c++23后，对于[非联合类类型]()：[非零大小]()的成员，始终按照『后声明的成员在类对象中有较高地址』的方式分配。

对齐会发生在成员间、或最后一个成员之后。

### 尺寸

除了基本的数据成员内存占用以及内存对齐，类字节大小还有以下计算要求：

* 空类的大小为1字节[^3]。
* 具有虚函数的类，虚指针占据一个指针大小的内存。
* 虚继承链上的类，虚基类指针占据一个指针大小的内存。

## 成员初始化

### 默认初始化器

使用[默认初始化器]()时，存在以下限制：

* 数组类型成员不能从初始化器推导大小。
* 引用成员不能绑定到临时量。

## 位域

位域的类型只能是[整数类型]()或[枚举类型]()，且无名位域不能声明为[cv限定]()。

位域的类型限制位域能表示的最大范围，即使『`char filed: 1000`』，其也只能表示『-128~127』范围的数，多余的位用于填充。

多个相邻的位域通常会打包存放在一个分配单元中[^4]，使用『零大小的无名位域』可以强制打破填充，其下一个位域总是分配到下一个分配单元中。[示例](#示例1)

c++20起，可以为位域添加[默认初始化器]()。





# 示例

## 示例1

```cpp
struct T1 {
    char filed1: 2;
    char filed2: 3;
    char filed3: 3;
};

struct T2 {
    char filed1: 2;
    char : 0;
    char filed2: 3;
    char : 0;
    char filed3: 3;
};

auto main() -> int {
    std::cout << sizeof(T1) << "\n"     // 1
              << sizeof(T2) << "\n";    // 3

    return 0;
}
```







[^1]:可以使用引用或指针
[^2]:[auto]()、[decltype(auto)]()

[^3]:对象在内存中需要拥有地址
[^4]:标准未定义该行为